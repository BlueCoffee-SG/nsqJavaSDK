package com.youzan.nsq.client.configs;

import com.youzan.util.NamedThreadFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * ConfigAccessAgent for testing, it caches what user feeds it and notify callbacks once new value passed in
 * via {@link TestConfigAccessAgent#updateValue(String, String[], SortedMap, boolean)}
 * Created by lin on 16/11/1.
 */
public class TestConfigAccessAgent extends ConfigAccessAgent {
    private final static Logger logger = LoggerFactory.getLogger(TestConfigAccessAgent.class);

    private static Map<String, IConfigAccessCallback> subscribeMap = new TreeMap<>();
    private static final ReentrantReadWriteLock subscribeLock = new ReentrantReadWriteLock();

    //value Map caches associated values to one subscribe
    private static Map<String, SortedMap<String, String>> valueMap = new TreeMap<>();
    private static Map<String, Boolean> onProcessMap = new TreeMap<>();
    private static final ReentrantReadWriteLock valueMapLock = new ReentrantReadWriteLock();

    private static final ExecutorService exec = Executors.newFixedThreadPool(2, new NamedThreadFactory("TestConfigAccessAgentCallbackInvoker", Thread.MAX_PRIORITY));

    public static SortedMap<String, String> updateValue(String domain, String[] keys, final SortedMap<String, String> newValueMap, boolean invokeOnProcess){
        assert null != newValueMap;
        final String key = generateSubscribeKey(domain, keys);
        SortedMap<String, String> oldValueMap;
        try{
            valueMapLock.writeLock().lock();
            oldValueMap = valueMap.put(key, newValueMap);
            onProcessMap.put(key, new Boolean(invokeOnProcess));
        }finally {
            valueMapLock.writeLock().unlock();
        }

        //kickoff associated callback
        exec.submit(new Runnable(){
            @Override
            public void run() {
                try {
                    subscribeLock.readLock().lock();
                    IConfigAccessCallback callback = subscribeMap.get(key);
                    boolean invokeOnProcess = onProcessMap.get(key);
                    if(null == callback) {
                        logger.info("Callback does not exist for key: {}. Ignore if it is first key:value update.", key);
                        return;
                    }
                    if(invokeOnProcess)
                        callback.process(newValueMap);
                    else
                        callback.fallback(newValueMap, new RuntimeException("Exception generated by TestConfigAccessAgent."));
                }finally {
                    subscribeLock.readLock().unlock();
                }
            }
        });

        return oldValueMap;
    }

    @Override
    public SortedMap<String, String> handleSubscribe(String domain, String[] keys, IConfigAccessCallback callback) {
        String key = generateSubscribeKey(domain, keys);
        try {
            subscribeLock.writeLock().lock();
            subscribeMap.put(key, callback);
        }finally {
            subscribeLock.writeLock().unlock();
        }
        //check value map to see if there is any value map match
        SortedMap<String, String> aValueMap;
        try{
            valueMapLock.readLock().lock();
            aValueMap = valueMap.get(key);
            return aValueMap;
        }finally {
            valueMapLock.readLock().unlock();
        }
    }

    @Override
    protected void kickoff() {
        logger.info("TestConfigAccessAgent kickoff.");
    }

    private static String generateSubscribeKey(String domain, final String[] keys){
        assert null != domain && null!= keys && keys.length > 0;
        //build keys out from domain and keys
        StringBuilder sb = new StringBuilder();
        sb.append(domain);
        for(String key:keys){
            sb.append(":" + key);
        }
        return sb.toString();
    }

    @Override
    public void close() {
        try{
            subscribeLock.writeLock().lock();
            subscribeMap.clear();

            valueMapLock.writeLock().lock();
            valueMap.clear();
            onProcessMap.clear();
        }finally {
            subscribeLock.writeLock().unlock();
            valueMapLock.writeLock().unlock();
        }
    }
}
